/*
 * activity_tracking.c
 *
 *  Created on: Dec 12, 2024
 *      Author: utente
 */

#include "activity_tracking.h"
#include <stdio.h>

void init_fsr_sensor(FSR_Sensor *sensor) {
    sensor->data = 0.0f;
    sensor->foot_on_ground = 0;  // Piede sollevato inizialmente
    sensor->prev_foot_on_ground = 0; // Stato precedente inizialmente sollevato
}

void UserActivity_init(UserActivity *user_activity) {
    user_activity->steps = 0;
    user_activity->last_step_time = 0;
    user_activity->consecutive_steps = 0;
    init_fsr_sensor(&user_activity->left_foot);
    init_fsr_sensor(&user_activity->right_foot);
    user_activity->state = RESTING;
}


void StepBuffer_init(StepBuffer *buffer, uint32_t* steps, uint16_t length) {

	buffer->buffer = steps;
	buffer->total_step_time = 0.0;
	buffer->index = 0;
	buffer->length = length;
	buffer->filled = 0;


    for (uint16_t i = 0; i < length; i++) {
    	steps[i] = 0;
    }

}

void read_forceSensor(uint16_t *d_out, FSR_Sensor *sensor) {
    float voltage = ((float)(*d_out)) * VREF / LEVELS;
    sensor->data = voltage;
    sensor->prev_foot_on_ground = sensor->foot_on_ground;
    sensor->foot_on_ground = (voltage > STEP_THRESHOLD) ? 1 : 0;
}

void update_step_count(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer) {
    uint32_t step_time; // Variabile per calcolare il tempo tra due passi consecutivi

    FSR_Sensor *feet[] = {&user_activity->left_foot, &user_activity->right_foot}; // Array di piedi

    for (int i = 0; i < 2; i++) {
        FSR_Sensor *foot = feet[i];

        if (foot->foot_on_ground && !foot->prev_foot_on_ground) {
            FSR_Sensor *other_foot = (i == 0) ? &user_activity->right_foot : &user_activity->left_foot;
            if (!other_foot->foot_on_ground) {
                // Calcola il tempo del passo
                step_time = current_time - user_activity->last_step_time;
                user_activity->steps++;
                add_step_time(step_buffer, step_time);
                user_activity->last_step_time = current_time;

                user_activity->consecutive_steps++;

                // Se l'utente era fermo e ha fatto abbastanza passi consecutivi, passa a camminare
                if (user_activity->state == RESTING && user_activity->consecutive_steps >= MIN_WALKING_STEPS) {
                    user_activity->state = WALKING;
                }
            }
        }
    }

    determine_activity(user_activity, current_time, step_buffer);
}



void determine_activity(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer) {
    if (current_time - user_activity->last_step_time >= INACTIVITY_TIMEOUT) {
        user_activity->state = RESTING;
        user_activity->consecutive_steps = 0;  // Reset dei passi consecutivi
        reset_step_buffer(step_buffer);
    } else if (user_activity->state != RESTING) { // Verifica che non sia in stato RESTING
        update_running_walking_state(step_buffer, user_activity);
    }
}


void update_running_walking_state(StepBuffer *step_buffer, UserActivity *user_activity) {
    uint32_t average_time = 0;

    if (step_buffer->filled > 0) {
        average_time = step_buffer->total_step_time / step_buffer->filled;
    }

    if (average_time < RUNNING_THRESHOLD) {
        user_activity->state = RUNNING;
    } else {
        user_activity->state = WALKING;
    }
}


void add_step_time(StepBuffer *buffer, uint32_t step_time) {


	buffer->total_step_time += step_time - buffer->buffer[buffer->index];
	buffer->buffer[buffer->index] = step_time;
	buffer->index = (buffer->index + 1) % buffer->length;
	if(buffer->filled < buffer->length){
		buffer->filled++;
	}

}

void reset_step_buffer(StepBuffer *buffer) {
    buffer->total_step_time = 0;       // Azzerare il tempo totale
    buffer->index = 0;                // Ripartire dall'inizio
    buffer->filled = 0;               // Indicare che non ci sono valori
    for (uint16_t i = 0; i < buffer->length; i++) {
        buffer->buffer[i] = 0;        // Facoltativo: azzerare i valori nel buffer
    }
}


const char* userState_to_string(UserState state) {
    switch (state) {
        case RESTING: return "RESTING";
        case WALKING: return "WALKING";
        case RUNNING: return "RUNNING";
        default: return "UNKNOWN";
    }
}



