/*
 * activity_tracking.c
 *
 *  Created on: Dec 12, 2024
 *      Author: utente
 */

#include "activity_tracking.h"
#include <stdio.h>

void init_fsr_sensor(FSR_Sensor *sensor) {
    sensor->data = 0.0f;
    sensor->foot_on_ground = 0;  // Piede sollevato inizialmente
    sensor->prev_foot_on_ground = 0; // Stato precedente inizialmente sollevato
}

void UserActivity_init(UserActivity *user_activity) {
    user_activity->steps = 0;
    user_activity->last_step_time = 0;
    init_fsr_sensor(&user_activity->left_foot);
    init_fsr_sensor(&user_activity->right_foot);
}

void StepBuffer_init(StepBuffer *buffer, uint32_t* steps, uint32_t length) {

	buffer->steps = steps;
    buffer->count = 0;
    buffer->total_step_time = 0;
    buffer->length = length;

    for (uint32_t i = 0; i < length; i++) {
        buffer->steps[i] = 0;
    }
}

void read_forceSensor(uint16_t *d_out, FSR_Sensor *sensor) {
    float voltage = ((float)(*d_out)) * VREF / LEVELS;
    sensor->data = voltage;
    sensor->prev_foot_on_ground = sensor->foot_on_ground;
    sensor->foot_on_ground = (voltage > STEP_THRESHOLD) ? 1 : 0;
}

void update_step_count(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer) {

	if (user_activity->left_foot.foot_on_ground && !user_activity->left_foot.prev_foot_on_ground) {
        // Controllo passo piede sinistro
        if (user_activity->right_foot.foot_on_ground == 0) {
            uint32_t step_time = current_time - user_activity->last_step_time;
            user_activity->steps++;
            add_step_time(step_buffer, step_time);
            printf("\rSteps: %d\n", user_activity->steps);
            user_activity->last_step_time = current_time;
        }
    }

    if (user_activity->right_foot.foot_on_ground && !user_activity->right_foot.prev_foot_on_ground) {
        // Controllo passo piede destro
        if (user_activity->left_foot.foot_on_ground == 0) {
            uint32_t step_time = current_time - user_activity->last_step_time;
            user_activity->steps++;
            add_step_time(step_buffer, step_time);
            printf("\rSteps: %d\n", user_activity->steps);
            user_activity->last_step_time = current_time;
        }
    }
}

void add_step_time(StepBuffer *buffer, uint32_t step_time) {
    buffer->total_step_time -= buffer->steps[buffer->index];
    buffer->steps[buffer->index] = step_time;
    buffer->total_step_time += step_time;
    buffer->count++;
}

void determine_activity(StepBuffer *step_buffer) {
	if (step_buffer->count == step_buffer->length) {
        uint32_t average_time = step_buffer->total_step_time / step_buffer->length;
        UserState state;

        if (average_time < RUNNING_THRESHOLD) {
            state = RUNNING;
        } else if (average_time < WALKING_THRESHOLD) {
            state = WALKING;
        } else {
            state = RESTING;
        }

        printf("User is: %s\n", userState_to_string(state));

        step_buffer->count = 0;
        step_buffer->total_step_time = 0;
    }
}

const char* userState_to_string(UserState state) {
    switch (state) {
        case RESTING: return "RESTING";
        case WALKING: return "WALKING";
        case RUNNING: return "RUNNING";
        default: return "UNKNOWN";
    }
}
