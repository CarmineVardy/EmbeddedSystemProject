/*
 * activity_tracking.c
 *
 *  Created on: Dec 12, 2024
 *      Author: utente
 */

#include "activity_tracking.h"
#include <stdio.h>

void init_fsr_sensor(FSR_Sensor *sensor) {
    sensor->data = 0.0f;
    sensor->foot_on_ground = 0;  // Piede sollevato inizialmente
    sensor->prev_foot_on_ground = 0; // Stato precedente inizialmente sollevato
}

void UserActivity_init(UserActivity *user_activity) {
    user_activity->steps = 0;
    user_activity->last_step_time = 0;
    init_fsr_sensor(&user_activity->left_foot);
    init_fsr_sensor(&user_activity->right_foot);
    user_activity->state = RESTING;
}

void StepBuffer_init(StepBuffer *buffer, uint32_t* steps, uint32_t length) {

	buffer->count = 0;
    buffer->total_step_time = 0;
    buffer->length = length;

}

void read_forceSensor(uint16_t *d_out, FSR_Sensor *sensor) {
    float voltage = ((float)(*d_out)) * VREF / LEVELS;
    sensor->data = voltage;
    sensor->prev_foot_on_ground = sensor->foot_on_ground;
    sensor->foot_on_ground = (voltage > STEP_THRESHOLD) ? 1 : 0;
}

void update_step_count(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer, LedArray *leds) {

    uint32_t step_time;

    // Rilevamento dei passi
    if (user_activity->left_foot.foot_on_ground && !user_activity->left_foot.prev_foot_on_ground) {
        // Controllo passo piede sinistro
        if (user_activity->right_foot.foot_on_ground == 0) {
            step_time = current_time - user_activity->last_step_time;
            user_activity->steps++;
            add_step_time(step_buffer, step_time);
            user_activity->last_step_time = current_time;  // Aggiorna l'ultimo passo

            // Se l'utente è in stato RESTING, considera il primo passo come WALKING
            if (user_activity->state == RESTING) {
                update_walking_state(user_activity);
            }
        }
    }

    if (user_activity->right_foot.foot_on_ground && !user_activity->right_foot.prev_foot_on_ground) {
        // Controllo passo piede destro
        if (user_activity->left_foot.foot_on_ground == 0) {
            step_time = current_time - user_activity->last_step_time;
            user_activity->steps++;
            add_step_time(step_buffer, step_time);
            user_activity->last_step_time = current_time;  // Aggiorna l'ultimo passo

            // Se l'utente è in stato RESTING, considera il primo passo come WALKING
            if (user_activity->state == RESTING) {
                update_walking_state(user_activity);
            }
        }
    }

    // Determina lo stato in base al tempo e alla condizione attuale
    determine_activity(user_activity, current_time, step_buffer);
}

void determine_activity(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer) {
    // Verifica se l'utente è fermo (nessuna attività per un certo tempo)
    if (current_time - user_activity->last_step_time >= INACTIVITY_TIMEOUT) {
        update_resting_state(user_activity);  // Usa la funzione per aggiornare lo stato a RESTING
    } else {
        // Se l'utente sta camminando, verifica se sta correndo o viceversa
        update_running_walking_state(step_buffer, user_activity);
    }
}

void update_running_walking_state(StepBuffer *step_buffer, UserActivity *user_activity) {

    if (step_buffer->count == step_buffer->length) {
        uint32_t average_time = step_buffer->total_step_time / step_buffer->length;
        // Determina se l'utente sta correndo
        if (average_time < RUNNING_THRESHOLD) {
            update_running_state(user_activity);  // Usa la funzione per aggiornare lo stato a RUNNING
        } else {
            update_walking_state(user_activity);  // Usa la funzione per aggiornare lo stato a WALKING
        }

        // Reset del buffer
        step_buffer->count = 0;
        step_buffer->total_step_time = 0;
    }
}

void add_step_time(StepBuffer *buffer, uint32_t step_time) {
    buffer->total_step_time += step_time;
    buffer->count++;
}

const char* userState_to_string(UserState state) {
    switch (state) {
        case RESTING: return "RESTING";
        case WALKING: return "WALKING";
        case RUNNING: return "RUNNING";
        default: return "UNKNOWN";
    }
}

void update_resting_state(UserActivity *user_activity) {
    user_activity->state = RESTING;
}

void update_walking_state(UserActivity *user_activity) {
    user_activity->state = WALKING;
}

void update_running_state(UserActivity *user_activity) {
    user_activity->state = RUNNING;
}


