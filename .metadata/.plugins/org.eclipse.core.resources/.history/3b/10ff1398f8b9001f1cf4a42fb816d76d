/*
 * activity_tracking.c
 *
 *  Created on: Dec 12, 2024
 *      Author: utente
 */

#include "activity_tracking.h"
#include <stdio.h>

void init_fsr_sensor(FSR_Sensor *sensor) {
    sensor->data = 0.0f;
    sensor->foot_on_ground = 0;  // Piede sollevato inizialmente
    sensor->prev_foot_on_ground = 0; // Stato precedente inizialmente sollevato
}

void UserActivity_init(UserActivity *user_activity) {
    user_activity->steps = 0;
    user_activity->last_step_time = 0;
    user_activity->consecutive_steps = 0;
    init_fsr_sensor(&user_activity->left_foot);
    init_fsr_sensor(&user_activity->right_foot);
    user_activity->state = RESTING;
}


void StepBuffer_init(StepBuffer *buffer, uint32_t* steps, uint16_t length) {

	buffer->buffer = steps;
	buffer->total_step_time = 0.0;
	buffer->index = 0;
	buffer->length = length;
	buffer->filled = 0;


    for (uint16_t i = 0; i < length; i++) {
    	steps[i] = 0;
    }

}

void read_forceSensor(uint16_t *d_out, FSR_Sensor *sensor) {
    float voltage = ((float)(*d_out)) * VREF / LEVELS;
    sensor->data = voltage;
    sensor->prev_foot_on_ground = sensor->foot_on_ground;
    sensor->foot_on_ground = (voltage > STEP_THRESHOLD) ? 1 : 0;
}

void update_step_count(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer) {
    uint32_t step_time;

    if (user_activity->left_foot.foot_on_ground && !user_activity->left_foot.prev_foot_on_ground) {
        if (user_activity->right_foot.foot_on_ground == 0) {
            step_time = current_time - user_activity->last_step_time;
            user_activity->steps++;
            add_step_time(step_buffer, step_time);
            user_activity->last_step_time = current_time;

            // Incrementa i passi consecutivi
            user_activity->consecutive_steps++;

            // Cambia stato se ha fatto abbastanza passi consecutivi
            if (user_activity->state == RESTING && user_activity->consecutive_steps >= MIN_WALKING_STEPS) {
                user_activity->state = WALKING;
            }
        }
    }

    if (user_activity->right_foot.foot_on_ground && !user_activity->right_foot.prev_foot_on_ground) {
        if (user_activity->left_foot.foot_on_ground == 0) {
            step_time = current_time - user_activity->last_step_time;
            user_activity->steps++;
            add_step_time(step_buffer, step_time);
            user_activity->last_step_time = current_time;

            // Incrementa i passi consecutivi
            user_activity->consecutive_steps++;

            // Cambia stato se ha fatto abbastanza passi consecutivi
            if (user_activity->state == RESTING && user_activity->consecutive_steps >= MIN_WALKING_STEPS) {
                user_activity->state = WALKING;
            }
        }
    }

    // Determina lo stato in base al tempo e alla condizione attuale
    determine_activity(user_activity, current_time, step_buffer);
}


void determine_activity(UserActivity *user_activity, uint32_t current_time, StepBuffer *step_buffer) {
    if (current_time - user_activity->last_step_time >= INACTIVITY_TIMEOUT) {
        user_activity->state = RESTING;
        user_activity->consecutive_steps = 0;  // Reset dei passi consecutivi
        reset_step_buffer(step_buffer);
    } else if (user_activity->state != RESTING) { // Verifica che non sia in stato RESTING
        update_running_walking_state(step_buffer, user_activity);
    }
}


void update_running_walking_state(StepBuffer *step_buffer, UserActivity *user_activity) {

    uint32_t average_time = step_buffer->total_step_time / step_buffer->filled;
        // Determina se l'utente sta correndo
    if (average_time < RUNNING_THRESHOLD) {
    	user_activity->state = RUNNING;
    } else {
    	user_activity->state = WALKING;
    }

}

void add_step_time(StepBuffer *buffer, uint32_t step_time) {


	buffer->total_step_time += step_time - buffer->buffer[buffer->index];
	buffer->buffer[buffer->index] = step_time;
	buffer->index = (buffer->index + 1) % buffer->length;
	if(buffer->filled < buffer->length){
		buffer->filled++;
	}

}

void reset_step_buffer(StepBuffer *buffer) {
    buffer->total_step_time = 0;       // Azzerare il tempo totale
    buffer->index = 0;                // Ripartire dall'inizio
    buffer->filled = 0;               // Indicare che non ci sono valori
    for (uint16_t i = 0; i < buffer->length; i++) {
        buffer->buffer[i] = 0;        // Facoltativo: azzerare i valori nel buffer
    }
}


const char* userState_to_string(UserState state) {
    switch (state) {
        case RESTING: return "RESTING";
        case WALKING: return "WALKING";
        case RUNNING: return "RUNNING";
        default: return "UNKNOWN";
    }
}



